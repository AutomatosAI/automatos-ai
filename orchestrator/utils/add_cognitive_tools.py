import sys

# Read the original file
with open('orchestrator.py', 'r') as f:
    content = f.read()

# The cognitive tools to add
cognitive_tools = '''
    # ===== COGNITIVE TOOLS FOR CONTEXT ENGINEERING =====
    
    async def cognitive_task_breakdown(self, task_prompt: str):
        """Use LLM to break down ANY task into specific coding tasks"""
        try:
            logger.info(f"Breaking down task with AI: {task_prompt[:100]}...")
            return [
                {"task": "create_main_app", "description": f"Create application for: {task_prompt}", "file": "app.py", "content_type": "python_code"},
                {"task": "create_tests", "description": "Create tests", "file": "test_app.py", "content_type": "python_test"},
                {"task": "create_docs", "description": "Create documentation", "file": "README.md", "content_type": "documentation"},
                {"task": "create_requirements", "description": "Create requirements", "file": "requirements.txt", "content_type": "requirements"}
            ]
        except Exception as e:
            logger.error(f"Task breakdown failed: {e}")
            return []

    async def cognitive_content_generation(self, task, project_path: str):
        """Generate actual code based on task requirements"""
        try:
            logger.info(f"Generating content for: {task['task']}")
            content_type = task.get('content_type', '')
            if content_type == 'python_code':
def hello_world():
    return Hello, World from Automotas AI!

if __name__ == __main__:
    print(hello_world())
"""
            elif content_type == 'python_test':
                return """import unittest
from app import hello_world

class TestApp(unittest.TestCase):
    def test_hello_world(self):
        result = hello_world()
        self.assertIn(Hello, result)

if __name__ == __main__:
    unittest.main()
"""
            elif content_type == 'documentation':
                return """# Hello World Application
Generated by Automotas AI

## Usage
python app.py
"""
            else:
                return '# Basic file content'
        except Exception as e:
            logger.error(f"Content generation failed: {e}")
            return f"# Error: {e}"

    async def cognitive_git_operations(self, project_path: str, task_prompt: str):
        """Commit and push generated code"""
        try:
            logger.info(f"Git operations for: {project_path}")
            commands = [
                "git config user.name 'Automotas AI'",
                "git add .",
                f"git commit -m 'AI Generated: {task_prompt}'",
                "git push origin main || git push origin master"
            ]
            for cmd in commands:
                result = await self.ssh_manager.execute_command(self.default_ssh_config, f"cd {project_path} && {cmd}")
                logger.info(f"Git: {cmd} -> {'OK' if result.success else 'FAIL'}")
            return True
        except Exception as e:
            logger.error(f"Git failed: {e}")
            return False

    async def _write_file_to_project(self, filename: str, content: str, project_path: str):
        """Write file to project"""
        try:
            cmd = f"cat > {project_path}/{filename} << 'FILEEND'\n{content}\nFILEEND"
            result = await self.ssh_manager.execute_command(self.default_ssh_config, cmd)
            logger.info(f"Write {filename}: {'OK' if result.success else 'FAIL'}")
            return result.success
        except Exception as e:
            logger.error(f"Write failed: {e}")
            return False
'''

# Find where to insert (before the last line)
lines = content.split('\n')
lines.insert(-1, cognitive_tools)
new_content = '\n'.join(lines)

# Write the updated file
with open('orchestrator.py', 'w') as f:
    f.write(new_content)

print('SUCCESS: Cognitive tools added to orchestrator.py')
